v2.0 raw
# This is an automatically-generated PIPS machine code file

# 0x0000: nop # first instruction does not execute
10000000 

# 0x0004: li   $s0, TERMINAL          # Save the terminal address
0a01ff10 

# 0x0008: li   $s1, 0                 # Initialize loop counter
0b010000 

# 0x000c: li   $s2, 15                # Initialize loop end
0c01000f 

# 0x0010: li   $sp, 0xf800            # Set up the stack
0e01f800 

# 0x0014: beq  $s1, $s2, exit         # Branch if reached the end of the loop
dbc10038 

# 0x0018: addi $a0, $s1, 1            # Set the input to the procedure
02b10001 

# 0x001c: jal  fibonacci              # Call the procedure fibonacci(n)
ff03003c 

# 0x0020: addi $a0, $v0, 0            # Put the result into the input
02110000 

# 0x0024: jal  print_decimal_number   # Call the procedure print_decimal_number
ff030094 

# 0x0028: li   $t0, NEWLINE           # Load in newline character
0601000a 

# 0x002c: sb   $t0, 0($s0)            # Print newline
b6a10000 

# 0x0030: addi $s1, $s1, 1            # Increment loop counter n += 1
0bb10001 

# 0x0034: j    loop                   # Continue looping
f0010014 

# 0x0038: j    HALT                   # Stop execution
f001ff00 

# 0x003c: slti $t0, $a0, 2            # Check if n < 2
76210002 

# 0x0040: beq  $t0, $zero, recur      # Branch if not (recursive case)
d601004c 

# 0x0044: addi $v0, $a0, 0            # Move input to return register
01210000 

# 0x0048: jr   $ra                    # Return to caller
f000f000 

# 0x004c: push $ra                    # Store the return address
1ee10002 cfe10000 

# 0x0054: push $a0                    # Store the input
1ee10002 c2e10000 

# 0x005c: addi $a0, $a0, -1           # Set the input (n-1)
0221ffff 

# 0x0060: jal  fibonacci              # Call the procedure fibonacci(n-1)
ff03003c 

# 0x0064: pop  $a0                    # Load the input n
a2e10000 0ee10002 

# 0x006c: push $v0                    # Store the result
1ee10002 c1e10000 

# 0x0074: addi $a0, $a0, -2           # Set the input (n-2)
0221fffe 

# 0x0078: jal  fibonacci              # Call the procedure fibonacci(n-2)
ff03003c 

# 0x007c: pop  $t0                    # Load the previous result
a6e10000 0ee10002 

# 0x0084: add  $v0, $t0, $v0          # fibonacci(n-1) + fibonacci(n-2)
01601000 

# 0x0088: pop  $ra                    # Load the return address
afe10000 0ee10002 

# 0x0090: jr   $ra                    # Return to caller
f000f000 

# 0x0094: bne  $a0, $zero, else_prnt  # Branch if in recursive case
e20100a4 

# 0x0098: li   $t0, ZERO              # Load in '0' character
06010030 

# 0x009c: sb   $t0, 0($s0)            # Print '0'
b6a10000 

# 0x00a0: jr   $ra                    # Return to caller
f000f000 

# 0x00a4: push $ra                    # Store the return address
1ee10002 cfe10000 

# 0x00ac: push $a0                    # Store the input
1ee10002 c2e10000 

# 0x00b4: li   $a1, 10                # Set the second input
0301000a 

# 0x00b8: jal  remainder              # Call procedure remainder(n,10)
ff030100 

# 0x00bc: pop  $a0                    # Load the input from the stack
a2e10000 0ee10002 

# 0x00c4: push $v0                    # Store digit on the stack
1ee10002 c1e10000 

# 0x00cc: slt  $t1, $v0, $a0          # (n > digit)?
77102000 

# 0x00d0: beq  $t1, $zero, exit_prnt  # Branch if we don't have the condition
d70100e4 

# 0x00d4: li   $a1, 10                # Set the second input
0301000a 

# 0x00d8: jal  quotient               # Call procedure quotient(n,10)
ff030118 

# 0x00dc: addi $a0, $v0, 0            # Set the input
02110000 

# 0x00e0: jal  print_decimal_number   # Call procedure print_decimal_number(n/10)
ff030094 

# 0x00e4: pop  $t0                    # Load digit from the stack
a6e10000 0ee10002 

# 0x00ec: addi $t0, $t0, ZERO         # Set the char digit + '0'
06610030 

# 0x00f0: sb   $t0, 0($s0)            # putchar(digit + '0')
b6a10000 

# 0x00f4: pop  $ra                    # Load the return address
afe10000 0ee10002 

# 0x00fc: jr   $ra                    # Return to caller
f000f000 

# 0x0100: j    if_rem			            # Branch to beginning of loop
f0010108 

# 0x0104: sub  $a0, $a0, $a1 		      # a = a - b
12203000 

# 0x0108: slt  $t0, $a0, $a1 		      # (a < b) = !(a >= b)
76203000 

# 0x010c: beq  $t0, $zero, loop_rem   # Branch if terminating condition
d6010104 

# 0x0110: addi $v0, $a0, 0 		        # Move 'a' into the result
01210000 

# 0x0114: jr   $ra			              # Return to caller
f000f000 

# 0x0118: addi $t0, $zero, 0          # Initialize loop counter
06010000 

# 0x011c: j    if_qtnt                # Branch to beginning of loop
f0010128 

# 0x0120: sub  $a0, $a0, $a1 		      # a = a - b
12203000 

# 0x0124: addi $t0, $t0, 1            # count += 1
06610001 

# 0x0128: slt  $t1, $a0, $a1 		      # (a < b) = !(a >= b)
77203000 

# 0x012c: beq  $t1, $zero, loop_qtnt  # Branch if terminating condition
d7010120 

# 0x0130: addi $v0, $t0, 0 		        # Move 'count' into the result
01610000 

# 0x0134: jr   $ra			              # Return to caller
f000f000 
